// Inline quiz questions for individual modules
// These are separate from the main QCM (module 13)

export interface InlineQuestion {
  id: number;
  question: string;
  options: string[];
  correctIndex: number;
  explanation: string;
}

export const GIT_QUESTIONS: InlineQuestion[] = [
  {
    id: 1,
    question: "A quoi sert Git ?",
    options: [
      "A compiler du code",
      "A versionner et suivre les modifications du code",
      "A deployer des applications",
      "A tester du code",
    ],
    correctIndex: 1,
    explanation: "Git est un systeme de controle de version qui permet de suivre chaque modification.",
  },
  {
    id: 2,
    question: "Que fait `git init` ?",
    options: [
      "Telecharge un depot distant",
      "Cree un nouveau depot Git local",
      "Supprime un depot Git",
      "Met a jour Git",
    ],
    correctIndex: 1,
    explanation: "`git init` initialise un nouveau depot Git dans le dossier courant.",
  },
  {
    id: 3,
    question: "Quelle commande permet d'ajouter des fichiers a la zone de staging ?",
    options: [
      "git commit",
      "git push",
      "git add",
      "git stage",
    ],
    correctIndex: 2,
    explanation: "`git add` ajoute les fichiers modifies a la zone de staging avant le commit.",
  },
  {
    id: 4,
    question: "Que fait `git commit -m 'message'` ?",
    options: [
      "Envoie le code sur GitHub",
      "Sauvegarde les changements stages avec un message",
      "Cree une nouvelle branche",
      "Fusionne deux branches",
    ],
    correctIndex: 1,
    explanation: "Le commit sauvegarde un snapshot des fichiers stages dans l'historique local.",
  },
  {
    id: 5,
    question: "Quelle est la difference entre `git pull` et `git push` ?",
    options: [
      "Il n'y a pas de difference",
      "pull envoie, push telecharge",
      "pull telecharge les changements distants, push envoie les locaux",
      "Les deux font la meme chose sur des branches differentes",
    ],
    correctIndex: 2,
    explanation: "`pull` recupere les modifications du serveur, `push` envoie vos commits vers le serveur.",
  },
  {
    id: 6,
    question: "Que fait `git status` ?",
    options: [
      "Affiche l'historique des commits",
      "Montre les fichiers modifies, stages et non suivis",
      "Affiche les branches",
      "Verifie la connexion a GitHub",
    ],
    correctIndex: 1,
    explanation: "`git status` montre l'etat actuel du depot : fichiers modifies, ajoutes ou non suivis.",
  },
  {
    id: 7,
    question: "A quoi sert un fichier `.gitignore` ?",
    options: [
      "A supprimer des fichiers du depot",
      "A lister les fichiers que Git doit ignorer",
      "A configurer les permissions Git",
      "A proteger les branches",
    ],
    correctIndex: 1,
    explanation: "Le `.gitignore` indique a Git quels fichiers/dossiers ne pas suivre (ex: node_modules).",
  },
  {
    id: 8,
    question: "Que fait `git clone <url>` ?",
    options: [
      "Cree une copie locale d'un depot distant",
      "Cree un nouveau depot vide",
      "Fusionne deux depots",
      "Sauvegarde le depot localement",
    ],
    correctIndex: 0,
    explanation: "`git clone` telecharge une copie complete d'un depot distant sur votre machine.",
  },
  {
    id: 9,
    question: "Que signifie un 'merge conflict' ?",
    options: [
      "Le depot est corrompu",
      "Deux personnes ont modifie les memes lignes de code",
      "La connexion a echoue",
      "Le commit est trop gros",
    ],
    correctIndex: 1,
    explanation: "Un conflit survient quand deux branches modifient la meme partie d'un fichier.",
  },
  {
    id: 10,
    question: "Quelle commande affiche l'historique des commits ?",
    options: [
      "git history",
      "git log",
      "git show",
      "git list",
    ],
    correctIndex: 1,
    explanation: "`git log` affiche la liste des commits avec auteur, date et message.",
  },
];

export const COMPOSE_QUESTIONS: InlineQuestion[] = [
  {
    id: 1,
    question: "Quel fichier Docker Compose utilise-t-il par defaut ?",
    options: [
      "docker-compose.json",
      "compose.yaml ou docker-compose.yml",
      "Dockerfile",
      "docker.config",
    ],
    correctIndex: 1,
    explanation: "Docker Compose cherche `compose.yaml`, `compose.yml`, `docker-compose.yml` ou `docker-compose.yaml`.",
  },
  {
    id: 2,
    question: "Que signifie `depends_on` dans un docker-compose.yml ?",
    options: [
      "Un service herite de la config d'un autre",
      "Un service demarre apres un autre",
      "Un service partage les volumes d'un autre",
      "Un service a le meme reseau qu'un autre",
    ],
    correctIndex: 1,
    explanation: "`depends_on` definit l'ordre de demarrage : le service attend que ses dependances soient lancees.",
  },
  {
    id: 3,
    question: "A quoi servent les volumes dans Docker Compose ?",
    options: [
      "A augmenter la memoire des conteneurs",
      "A persister des donnees meme si le conteneur est supprime",
      "A accelerer le demarrage",
      "A compresser les fichiers",
    ],
    correctIndex: 1,
    explanation: "Les volumes permettent de persister les donnees en dehors du cycle de vie du conteneur.",
  },
  {
    id: 4,
    question: "Que fait `docker compose up -d` ?",
    options: [
      "Demarre les services en mode debug",
      "Demarre les services en arriere-plan (detached)",
      "Telecharge les images seulement",
      "Supprime et recree les services",
    ],
    correctIndex: 1,
    explanation: "Le flag `-d` (detached) lance les conteneurs en arriere-plan.",
  },
  {
    id: 5,
    question: "Comment les services Docker Compose communiquent-ils entre eux ?",
    options: [
      "Via l'adresse IP de la machine",
      "Via le nom du service comme nom d'hote",
      "Ils ne peuvent pas communiquer",
      "Via des fichiers partages",
    ],
    correctIndex: 1,
    explanation: "Docker Compose cree un reseau ou chaque service est accessible par son nom.",
  },
  {
    id: 6,
    question: "Que fait `docker compose down -v` ?",
    options: [
      "Arrete les services en mode verbose",
      "Arrete les services et supprime les volumes",
      "Affiche la version",
      "Arrete un seul service",
    ],
    correctIndex: 1,
    explanation: "Le flag `-v` supprime aussi les volumes nommes declares dans le compose file.",
  },
  {
    id: 7,
    question: "Quelle section definit les variables d'environnement dans docker-compose.yml ?",
    options: [
      "config",
      "environment",
      "env_vars",
      "settings",
    ],
    correctIndex: 1,
    explanation: "La cle `environment` permet de definir des variables d'environnement pour un service.",
  },
  {
    id: 8,
    question: "Comment reconstruire les images apres modification du code ?",
    options: [
      "docker compose restart",
      "docker compose up --build",
      "docker compose rebuild",
      "docker compose update",
    ],
    correctIndex: 1,
    explanation: "`--build` force la reconstruction des images avant de demarrer les services.",
  },
  {
    id: 9,
    question: "Que fait `restart: unless-stopped` ?",
    options: [
      "Empeche le redemarrage du conteneur",
      "Redemarre le conteneur sauf s'il a ete arrete manuellement",
      "Redemarre le conteneur une seule fois",
      "Redemarre le conteneur toutes les 5 minutes",
    ],
    correctIndex: 1,
    explanation: "Le conteneur redemarre automatiquement sauf si vous l'arretez explicitement.",
  },
  {
    id: 10,
    question: "Quelle commande affiche les logs de tous les services ?",
    options: [
      "docker compose output",
      "docker compose logs",
      "docker compose print",
      "docker compose debug",
    ],
    correctIndex: 1,
    explanation: "`docker compose logs` affiche les logs. Ajoutez `-f` pour les suivre en temps reel.",
  },
];

export const MULTISTAGE_QUESTIONS: InlineQuestion[] = [
  {
    id: 1,
    question: "Quel est le principal avantage du multi-stage build ?",
    options: [
      "Le build est plus rapide",
      "L'image finale est beaucoup plus legere",
      "Le code est mieux organise",
      "Le Dockerfile est plus court",
    ],
    correctIndex: 1,
    explanation: "Le multi-stage permet de ne garder que le necessaire dans l'image finale, reduisant sa taille de 80%+.",
  },
  {
    id: 2,
    question: "Que fait `COPY --from=builder /app/dist ./dist` ?",
    options: [
      "Copie depuis le host vers l'image",
      "Copie depuis un stage precedent nomme 'builder'",
      "Copie depuis une image externe",
      "Copie depuis un volume Docker",
    ],
    correctIndex: 1,
    explanation: "`--from=builder` reference un stage precedent defini par `FROM ... AS builder`.",
  },
  {
    id: 3,
    question: "Combien de `FROM` peut-on avoir dans un Dockerfile multi-stage ?",
    options: [
      "Un seul",
      "Deux maximum",
      "Autant qu'on veut",
      "Trois maximum",
    ],
    correctIndex: 2,
    explanation: "On peut avoir autant de stages (FROM) qu'on veut. Seul le dernier produit l'image finale.",
  },
  {
    id: 4,
    question: "A quoi sert `.dockerignore` ?",
    options: [
      "A ignorer les erreurs Docker",
      "A reduire le contexte de build en excluant des fichiers",
      "A desactiver des fonctionnalites Docker",
      "A ignorer certaines instructions du Dockerfile",
    ],
    correctIndex: 1,
    explanation: "`.dockerignore` empeche l'envoi de fichiers inutiles (node_modules, .git) au daemon Docker.",
  },
  {
    id: 5,
    question: "Quelle est la difference entre `ARG` et `ENV` ?",
    options: [
      "Il n'y a pas de difference",
      "ARG est disponible au build, ENV au runtime",
      "ARG est pour Linux, ENV pour Windows",
      "ENV est disponible au build, ARG au runtime",
    ],
    correctIndex: 1,
    explanation: "ARG n'existe que pendant le build. ENV est embarque dans l'image et disponible au runtime.",
  },
  {
    id: 6,
    question: "Pourquoi copier `package*.json` AVANT le reste du code ?",
    options: [
      "C'est obligatoire",
      "Pour que npm install utilise le cache si les deps n'ont pas change",
      "Pour accelerer la copie des fichiers",
      "Pour eviter les conflits de version",
    ],
    correctIndex: 1,
    explanation: "Docker cache les layers. Si package.json n'a pas change, npm install est en cache = build rapide.",
  },
  {
    id: 7,
    question: "Quelle image de base produit generalement la plus petite image finale ?",
    options: [
      "node:18",
      "node:18-slim",
      "node:18-alpine",
      "ubuntu:22.04",
    ],
    correctIndex: 2,
    explanation: "Alpine Linux est la distro la plus legere (~5 MB). node:18-alpine fait ~180 MB vs ~1.1 GB pour node:18.",
  },
  {
    id: 8,
    question: "Dans un multi-stage, que contient l'image finale ?",
    options: [
      "Tous les fichiers de tous les stages",
      "Seulement les fichiers du dernier stage + ce qu'on copie explicitement",
      "Seulement les fichiers du premier stage",
      "Tous les packages npm installes",
    ],
    correctIndex: 1,
    explanation: "L'image finale ne contient que le dernier stage. Il faut COPY --from pour recuperer des fichiers.",
  },
  {
    id: 9,
    question: "Que fait `--build-arg NODE_ENV=production` ?",
    options: [
      "Definit une variable d'environnement permanente",
      "Passe une valeur a un ARG defini dans le Dockerfile",
      "Configure Node.js en mode production",
      "Desactive les outils de developpement",
    ],
    correctIndex: 1,
    explanation: "`--build-arg` passe une valeur a une instruction ARG du Dockerfile au moment du build.",
  },
  {
    id: 10,
    question: "Une image Node.js classique fait ~1.1 GB. Avec multi-stage + Alpine, on obtient :",
    options: [
      "~800 MB",
      "~500 MB",
      "~150-200 MB",
      "~50 MB",
    ],
    correctIndex: 2,
    explanation: "Un multi-stage avec Alpine reduit l'image de ~84%, passant de 1.1 GB a ~150-200 MB.",
  },
];

export const NETWORKING_QUESTIONS: InlineQuestion[] = [
  {
    id: 1,
    question: "Quel est le type de reseau Docker par defaut ?",
    options: [
      "host",
      "bridge",
      "overlay",
      "none",
    ],
    correctIndex: 1,
    explanation: "Par defaut, Docker utilise le reseau `bridge` qui isole les conteneurs du host.",
  },
  {
    id: 2,
    question: "Quel avantage a un reseau bridge custom par rapport au bridge par defaut ?",
    options: [
      "Il est plus rapide",
      "Il offre la resolution DNS automatique par nom de conteneur",
      "Il utilise moins de memoire",
      "Il est plus securise par defaut",
    ],
    correctIndex: 1,
    explanation: "Sur un bridge custom, les conteneurs se trouvent par nom (DNS). Sur le defaut, il faut les IP.",
  },
  {
    id: 3,
    question: "Quelle commande cree un reseau Docker ?",
    options: [
      "docker network add mynet",
      "docker network create mynet",
      "docker create network mynet",
      "docker net create mynet",
    ],
    correctIndex: 1,
    explanation: "`docker network create` cree un nouveau reseau. Par defaut, c'est un bridge.",
  },
  {
    id: 4,
    question: "Que fait l'instruction `EXPOSE 3000` dans un Dockerfile ?",
    options: [
      "Ouvre le port 3000 sur le host",
      "Bloque le port 3000",
      "Documente que l'app ecoute sur le port 3000 (sans ouvrir)",
      "Redirige le port 3000 vers le port 80",
    ],
    correctIndex: 2,
    explanation: "EXPOSE est une documentation. Pour vraiment publier le port, il faut `-p` au run.",
  },
  {
    id: 5,
    question: "Comment connecter un conteneur deja en cours a un reseau ?",
    options: [
      "docker network connect mynet mon-conteneur",
      "docker network add mynet mon-conteneur",
      "docker connect mon-conteneur mynet",
      "docker run --network mynet mon-conteneur",
    ],
    correctIndex: 0,
    explanation: "`docker network connect` attache un conteneur existant a un reseau supplementaire.",
  },
  {
    id: 6,
    question: "Le reseau `host` signifie que :",
    options: [
      "Le conteneur est isole du host",
      "Le conteneur partage le reseau du host (pas d'isolation)",
      "Le conteneur n'a pas de reseau",
      "Le conteneur se connecte a Internet via VPN",
    ],
    correctIndex: 1,
    explanation: "En mode `host`, le conteneur utilise directement le reseau de la machine. Pas de `-p` necessaire.",
  },
  {
    id: 7,
    question: "Comment isoler une base de donnees du frontend ?",
    options: [
      "Utiliser des ports differents",
      "Mettre le frontend et la DB sur des reseaux separes",
      "Utiliser un mot de passe sur la DB",
      "Desactiver le reseau du frontend",
    ],
    correctIndex: 1,
    explanation: "Des reseaux separes empechent toute communication directe. L'API sert de pont entre les deux.",
  },
  {
    id: 8,
    question: "Quelle commande inspecte un reseau Docker ?",
    options: [
      "docker network show mynet",
      "docker network inspect mynet",
      "docker network info mynet",
      "docker network status mynet",
    ],
    correctIndex: 1,
    explanation: "`docker network inspect` montre les details : subnet, gateway, conteneurs connectes.",
  },
  {
    id: 9,
    question: "Dans Docker Compose, les services sont-ils sur le meme reseau par defaut ?",
    options: [
      "Non, chaque service a son propre reseau",
      "Oui, Compose cree un reseau partage automatiquement",
      "Non, il faut configurer le reseau manuellement",
      "Oui, mais ils ne peuvent pas communiquer",
    ],
    correctIndex: 1,
    explanation: "Docker Compose cree automatiquement un reseau bridge pour tous les services du projet.",
  },
  {
    id: 10,
    question: "Quelle est la difference entre `-p 8080:80` et `EXPOSE 80` ?",
    options: [
      "Pas de difference",
      "-p publie le port (accessible), EXPOSE documente seulement",
      "EXPOSE publie le port, -p le bloque",
      "-p est pour le dev, EXPOSE pour la prod",
    ],
    correctIndex: 1,
    explanation: "`-p` rend le port accessible depuis l'exterieur. `EXPOSE` est juste informatif.",
  },
];

export const SECURITY_QUESTIONS: InlineQuestion[] = [
  {
    id: 1,
    question: "Pourquoi utiliser des variables d'environnement pour les mots de passe ?",
    options: [
      "C'est plus rapide",
      "Pour ne pas les hardcoder dans le code ou l'image",
      "Pour les chiffrer automatiquement",
      "C'est obligatoire pour Docker",
    ],
    correctIndex: 1,
    explanation: "Les variables d'environnement separent la config du code. Le code peut etre public sans risque.",
  },
  {
    id: 2,
    question: "Quelle instruction Dockerfile permet de ne PAS executer en root ?",
    options: [
      "ADMIN off",
      "USER appuser",
      "ROOT false",
      "PERMISSION user",
    ],
    correctIndex: 1,
    explanation: "L'instruction `USER` change l'utilisateur qui execute les commandes suivantes et le CMD.",
  },
  {
    id: 3,
    question: "Pourquoi ne pas utiliser le tag `:latest` en production ?",
    options: [
      "Il est plus lent",
      "Il peut changer a tout moment et casser l'app",
      "Il est plus gros",
      "Il n'est pas disponible sur Docker Hub",
    ],
    correctIndex: 1,
    explanation: "`:latest` pointe vers la derniere version, qui peut changer. Pinner la version garantit la stabilite.",
  },
  {
    id: 4,
    question: "Que fait `docker run --read-only` ?",
    options: [
      "Le conteneur ne peut lire aucun fichier",
      "Le filesystem du conteneur est en lecture seule",
      "Les logs sont desactives",
      "Le conteneur ne peut pas acceder au reseau",
    ],
    correctIndex: 1,
    explanation: "`--read-only` empeche toute ecriture dans le filesystem, une protection contre les modifications malveillantes.",
  },
  {
    id: 5,
    question: "A quoi sert `HEALTHCHECK` dans un Dockerfile ?",
    options: [
      "A verifier que Docker est installe",
      "A verifier periodiquement que l'application fonctionne",
      "A monitorer l'utilisation CPU",
      "A redemarrer le conteneur automatiquement",
    ],
    correctIndex: 1,
    explanation: "HEALTHCHECK execute une commande regulierement pour verifier que le service repond correctement.",
  },
  {
    id: 6,
    question: "Quelle commande scanne les vulnerabilites d'une image ?",
    options: [
      "docker scan",
      "docker scout quickview",
      "docker security check",
      "docker audit",
    ],
    correctIndex: 1,
    explanation: "`docker scout` est l'outil officiel pour scanner les CVE (vulnerabilites) des images.",
  },
  {
    id: 7,
    question: "Que faut-il mettre dans `.dockerignore` pour la securite ?",
    options: [
      "Le Dockerfile",
      "Les fichiers .env, .git, cles privees (*.pem)",
      "Les fichiers HTML",
      "Le dossier src/",
    ],
    correctIndex: 1,
    explanation: "Les fichiers sensibles (.env, .git, cles) ne doivent jamais etre inclus dans le contexte de build.",
  },
  {
    id: 8,
    question: "Comment passer un fichier .env a Docker Compose ?",
    options: [
      "COPY .env /app/",
      "La directive env_file dans le service",
      "docker compose --env .env",
      "ENV_FILE=.env docker compose up",
    ],
    correctIndex: 1,
    explanation: "`env_file: .env` dans le docker-compose.yml charge automatiquement les variables du fichier.",
  },
  {
    id: 9,
    question: "Pourquoi les variables d'environnement ne sont pas ideales pour les secrets ?",
    options: [
      "Elles sont trop lentes",
      "Elles sont visibles avec `docker inspect`",
      "Elles ne fonctionnent pas en production",
      "Elles sont limitees a 255 caracteres",
    ],
    correctIndex: 1,
    explanation: "`docker inspect` affiche toutes les env vars en clair. Docker Secrets est plus securise.",
  },
  {
    id: 10,
    question: "Quel est le risque principal d'executer un conteneur en mode `--privileged` ?",
    options: [
      "Le conteneur est plus lent",
      "Le conteneur a un acces total au host (dangereux)",
      "Le conteneur utilise plus de memoire",
      "Le conteneur ne peut pas etre arrete",
    ],
    correctIndex: 1,
    explanation: "`--privileged` donne au conteneur tous les droits sur le host. A eviter sauf cas tres specifiques.",
  },
];

export const ADVANCED_COMPOSE_QUESTIONS: InlineQuestion[] = [
  {
    id: 1,
    question: "Que verifie un healthcheck dans Docker Compose ?",
    options: [
      "Que l'image est a jour",
      "Que le service repond correctement",
      "Que le fichier compose est valide",
      "Que le reseau fonctionne",
    ],
    correctIndex: 1,
    explanation: "Le healthcheck execute un test (ex: curl) pour verifier que le service est fonctionnel.",
  },
  {
    id: 2,
    question: "Que fait `depends_on: db: condition: service_healthy` ?",
    options: [
      "Demarre le service en meme temps que la DB",
      "Attend que le healthcheck de la DB passe avant de demarrer",
      "Connecte le service au reseau de la DB",
      "Partage les volumes de la DB",
    ],
    correctIndex: 1,
    explanation: "Avec `condition: service_healthy`, le service attend que la DB soit vraiment prete (healthcheck OK).",
  },
  {
    id: 3,
    question: "A quoi servent les profiles dans Docker Compose ?",
    options: [
      "A definir des utilisateurs differents",
      "A activer des services selon le contexte (dev, prod, debug)",
      "A limiter les ressources CPU",
      "A configurer le reseau",
    ],
    correctIndex: 1,
    explanation: "Les profiles permettent de n'activer certains services que dans certains contextes.",
  },
  {
    id: 4,
    question: "Quel fichier est automatiquement charge en plus de docker-compose.yml ?",
    options: [
      "docker-compose.prod.yml",
      "docker-compose.override.yml",
      "docker-compose.local.yml",
      "docker-compose.extra.yml",
    ],
    correctIndex: 1,
    explanation: "Docker Compose charge automatiquement `docker-compose.override.yml` s'il existe.",
  },
  {
    id: 5,
    question: "Comment limiter la memoire d'un service a 512 MB ?",
    options: [
      "memory: 512MB dans environment",
      "deploy: resources: limits: memory: 512M",
      "mem_limit: 512",
      "RAM: 512MB",
    ],
    correctIndex: 1,
    explanation: "Les limites de ressources se definissent sous `deploy.resources.limits`.",
  },
  {
    id: 6,
    question: "Que fait `docker compose up --scale web=3` ?",
    options: [
      "Lance 3 versions du fichier compose",
      "Lance 3 instances du service web",
      "Triple la memoire du service web",
      "Replique les donnees 3 fois",
    ],
    correctIndex: 1,
    explanation: "`--scale` cree plusieurs replicas d'un service. Utile pour le load balancing.",
  },
  {
    id: 7,
    question: "Que signifie le prefixe `x-` dans un docker-compose.yml ?",
    options: [
      "Un service experimental",
      "Un champ d'extension personnalise (ignore par Docker)",
      "Un service desactive",
      "Un service externe",
    ],
    correctIndex: 1,
    explanation: "Les champs `x-` sont des extensions YAML. Docker les ignore, mais on peut les reutiliser avec des ancres.",
  },
  {
    id: 8,
    question: "Quelle syntaxe YAML permet de reutiliser un bloc de configuration ?",
    options: [
      "include: &block",
      "Ancres (&nom) et alias (*nom)",
      "import: block",
      "extend: block",
    ],
    correctIndex: 1,
    explanation: "YAML supporte les ancres `&nom` (definir) et `*nom` (reutiliser) pour eviter la duplication.",
  },
  {
    id: 9,
    question: "Comment utiliser un fichier compose specifique pour la prod ?",
    options: [
      "docker compose --env prod up",
      "docker compose -f docker-compose.yml -f docker-compose.prod.yml up",
      "docker compose up --prod",
      "COMPOSE_ENV=prod docker compose up",
    ],
    correctIndex: 1,
    explanation: "L'option `-f` permet de specifier plusieurs fichiers. Le second override le premier.",
  },
  {
    id: 10,
    question: "Quel probleme pose `--scale web=3` si le service publie un port fixe ?",
    options: [
      "Le port est partage entre les 3 instances",
      "Conflit de port : impossible d'avoir 3 fois le meme port sur le host",
      "Les conteneurs se bloquent mutuellement",
      "Aucun probleme",
    ],
    correctIndex: 1,
    explanation: "Un port host ne peut etre utilise qu'une fois. Il faut retirer le mapping ou utiliser un load balancer.",
  },
];

export const REGISTRY_QUESTIONS: InlineQuestion[] = [
  {
    id: 1,
    question: "Qu'est-ce que Docker Hub ?",
    options: [
      "Un outil de build Docker",
      "Un registry public pour stocker et partager des images",
      "Un IDE pour Docker",
      "Un systeme d'exploitation Docker",
    ],
    correctIndex: 1,
    explanation: "Docker Hub est le registry par defaut. C'est comme GitHub mais pour les images Docker.",
  },
  {
    id: 2,
    question: "Quel est le format complet d'un nom d'image Docker ?",
    options: [
      "nom:version",
      "registry/utilisateur/repository:tag",
      "utilisateur/image",
      "docker://image:tag",
    ],
    correctIndex: 1,
    explanation: "Le format complet est `registry/user/repo:tag`. Docker Hub et latest sont les valeurs par defaut.",
  },
  {
    id: 3,
    question: "Pourquoi ne pas utiliser le tag `latest` en production ?",
    options: [
      "Il est reserve aux images officielles",
      "Il peut pointer vers une version differente a tout moment",
      "Il est plus lent a telecharger",
      "Il n'existe pas sur Docker Hub",
    ],
    correctIndex: 1,
    explanation: "`latest` est mis a jour a chaque push. En prod, pinner une version precise (ex: v1.2.3).",
  },
  {
    id: 4,
    question: "Quelle commande pousse une image vers Docker Hub ?",
    options: [
      "docker upload monimage",
      "docker push monuser/monimage:v1.0",
      "docker send monimage",
      "docker publish monimage",
    ],
    correctIndex: 1,
    explanation: "`docker push` envoie une image vers le registry. Le nom doit inclure votre username.",
  },
  {
    id: 5,
    question: "Que faut-il faire AVANT de push une image ?",
    options: [
      "docker build seulement",
      "docker login pour s'authentifier",
      "docker pull pour verifier",
      "docker init pour preparer",
    ],
    correctIndex: 1,
    explanation: "Il faut se connecter avec `docker login` avant de pouvoir push une image.",
  },
  {
    id: 6,
    question: "Comment tagger une image existante pour Docker Hub ?",
    options: [
      "docker rename image newname",
      "docker tag image monuser/image:v1.0",
      "docker label image v1.0",
      "docker name image monuser/image",
    ],
    correctIndex: 1,
    explanation: "`docker tag` cree un alias (tag) pour une image existante avec le format registry/user/repo:tag.",
  },
  {
    id: 7,
    question: "Qu'est-ce qu'un registry prive ?",
    options: [
      "Docker Hub avec un compte payant",
      "Un serveur de stockage d'images accessible uniquement en interne",
      "Un conteneur special",
      "Un VPN pour Docker",
    ],
    correctIndex: 1,
    explanation: "Un registry prive stocke les images en interne, pour la securite et la conformite.",
  },
  {
    id: 8,
    question: "Quel service AWS heberge des images Docker ?",
    options: [
      "S3",
      "ECR (Elastic Container Registry)",
      "EC2",
      "Lambda",
    ],
    correctIndex: 1,
    explanation: "AWS ECR est le service de registry Docker d'Amazon. Google a GCR, Azure a ACR.",
  },
  {
    id: 9,
    question: "Quelle strategie de tag est la plus fiable pour la tracabilite ?",
    options: [
      "latest",
      "Le SHA du commit Git",
      "La date du jour",
      "Un numero aleatoire",
    ],
    correctIndex: 1,
    explanation: "Le SHA Git lie l'image exactement au code source correspondant. Tracabilite parfaite.",
  },
  {
    id: 10,
    question: "Comment lancer un registry Docker local ?",
    options: [
      "docker registry start",
      "docker run -d -p 5000:5000 registry:2",
      "docker compose registry",
      "docker hub --local",
    ],
    correctIndex: 1,
    explanation: "L'image `registry:2` est le registry officiel Docker. Port 5000 par defaut.",
  },
];

export const CICD_QUESTIONS: InlineQuestion[] = [
  {
    id: 1,
    question: "Que signifie CI dans CI/CD ?",
    options: [
      "Container Integration",
      "Continuous Integration",
      "Code Installation",
      "Cloud Infrastructure",
    ],
    correctIndex: 1,
    explanation: "CI = Continuous Integration : tester et integrer le code automatiquement a chaque push.",
  },
  {
    id: 2,
    question: "Ou se placent les workflows GitHub Actions ?",
    options: [
      "A la racine du projet",
      "Dans .github/workflows/",
      "Dans .ci/",
      "Dans le fichier package.json",
    ],
    correctIndex: 1,
    explanation: "GitHub Actions lit les fichiers YAML dans le dossier `.github/workflows/`.",
  },
  {
    id: 3,
    question: "Qu'est-ce qu'un 'job' dans GitHub Actions ?",
    options: [
      "Un fichier de configuration",
      "Un ensemble de steps qui s'executent sur un runner",
      "Un conteneur Docker",
      "Une branche Git",
    ],
    correctIndex: 1,
    explanation: "Un job est un groupe de steps qui tournent sur la meme machine virtuelle (runner).",
  },
  {
    id: 4,
    question: "Comment stocker un mot de passe Docker Hub dans GitHub ?",
    options: [
      "Dans le fichier workflow.yml en clair",
      "Dans les GitHub Secrets du repository",
      "Dans un fichier .env",
      "Dans le README",
    ],
    correctIndex: 1,
    explanation: "Les Secrets GitHub sont chiffres et accessibles dans les workflows via `secrets.NOM`.",
  },
  {
    id: 5,
    question: "Quel trigger lance un workflow a chaque push sur main ?",
    options: [
      "on: commit: main",
      "on: push: branches: [main]",
      "trigger: push-main",
      "when: push to main",
    ],
    correctIndex: 1,
    explanation: "La syntaxe `on: push: branches: [main]` declenche le workflow a chaque push sur main.",
  },
  {
    id: 6,
    question: "A quoi sert `docker/build-push-action` ?",
    options: [
      "A installer Docker sur le runner",
      "A builder et pusher une image Docker en une seule action",
      "A tester les images Docker",
      "A scanner les vulnerabilites",
    ],
    correctIndex: 1,
    explanation: "Cette action officielle Docker combine le build et le push en une seule etape optimisee.",
  },
  {
    id: 7,
    question: "Pourquoi faire des builds multi-plateformes en CI ?",
    options: [
      "Pour que le build soit plus rapide",
      "Pour supporter ARM (Raspberry Pi, Mac M1) et x86",
      "Pour reduire la taille de l'image",
      "Pour tester sur plusieurs OS",
    ],
    correctIndex: 1,
    explanation: "Les builds multi-plateformes produisent des images pour differentes architectures (AMD64, ARM64).",
  },
  {
    id: 8,
    question: "Que fait l'action `actions/checkout@v4` ?",
    options: [
      "Cree un nouveau repository",
      "Clone le code du repository dans le runner",
      "Deploie le code en production",
      "Verifie la syntaxe du code",
    ],
    correctIndex: 1,
    explanation: "checkout telecharge le code source du repo pour que les etapes suivantes puissent l'utiliser.",
  },
  {
    id: 9,
    question: "Comment ajouter un badge de status CI dans le README ?",
    options: [
      "Docker le genere automatiquement",
      "Avec un lien Markdown vers l'URL du badge GitHub Actions",
      "Avec la commande gh badge",
      "En activant une option dans les settings",
    ],
    correctIndex: 1,
    explanation: "GitHub fournit une URL de badge par workflow qu'on peut inserer en Markdown dans le README.",
  },
  {
    id: 10,
    question: "Quelle bonne pratique evite de casser la prod accidentellement ?",
    options: [
      "Ne jamais faire de push",
      "Branch protection rules + CI obligatoire avant merge",
      "Deployer uniquement le lundi",
      "Utiliser un seul fichier pour tout le code",
    ],
    correctIndex: 1,
    explanation: "Proteger la branche main + CI obligatoire empeche de merger du code qui ne passe pas les tests.",
  },
];
